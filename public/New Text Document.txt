/* eslint-disable react/jsx-no-duplicate-props */
/* eslint-disable no-unused-vars */
import React, { useState, useRef } from 'react';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { fabric } from 'fabric';
import { Rnd } from 'react-rnd';
import './App.css';
import TextComponent from './components/TextComponent';
import CheckBoxComponent from './components/CheckBoxComponent';

const ItemTypes = {
  TEXT: 'text',
  TEXTAREA: 'textarea',
  CHECKBOX: 'checkbox',
  RADIO: 'radio',
  NEW_TEXT: 'newText',
  NEW_CHECKBOX: 'newCheckbox',
};


// sidebar for drag and drop
function SidebarItem({ type, label, disabled }) {
  const [{ isDragging }, drag] = useDrag(() => ({
    type: type,
    item: { label, type },
    collect: (monitor) => ({
      isDragging: !!monitor.isDragging(),
    }),
    canDrag: !disabled,
  }));

  return (
    <div
      ref={drag}
      className="sidebar-item"
      style={{
        opacity: isDragging || disabled ? 0.5 : 1,
        backgroundColor: disabled ? 'gray' : 'lightblue',
        padding: '10px',
        marginBottom: '10px',
        cursor: disabled ? 'not-allowed' : 'grab',
      }}
    >
      {label}
    </div>
  );
}

// canvas area for draggable components
function CanvasArea({ onDrop, children, pageSize='A4' }) {

  const canvasRef = React.useRef(null);

  const [, drop] = useDrop(() => ({
    accept: [ItemTypes.TEXT, ItemTypes.TEXTAREA, ItemTypes.CHECKBOX, ItemTypes.RADIO, ItemTypes.NEW_TEXT, ItemTypes.NEW_CHECKBOX],
    drop: (item, monitor) => {
      const offset = monitor.getClientOffset();
      const x = offset.x;
      const y = offset.y;
      onDrop(x, y, item.type);
    },
  }));

  return (
    <div
      className={`canvas-area ${pageSize.toLowerCase()}`}
      ref={(node) => {
        drop(node);
        canvasRef.current = node;
      }}
      style={{
        position: 'relative',
        width: '100%',
        height: '100%',
        backgroundColor: '#fafafa',
        border: '2px solid #007bff',
        borderRadius: '10px',
      }}
    >
      {children}
    </div>
  );
}

// draggable input component with resizing
function DraggableInput({ type, left, top, width, height, onResizeStop, onDragStop }) {

  const [question, setQuestion] = useState('Question');
  const [options, setOptions] = useState([{ id: 1, text: 'Option 1' }]);
  const canvasRef = document.querySelector('.canvas-area');


  const handleQuestionChange = (e) => {
    setQuestion(e.target.value);
  };

  const addOption = () => {
    setOptions([...options, { id: options.length + 1, text: `Option ${options.length + 1}` }]);
  };

  const handleOptionChange = (index, text) => {
    const updatedOptions = [...options];
    updatedOptions[index].text = text;
    setOptions(updatedOptions);
  };

  const inputTypes = {
    [ItemTypes.TEXT]: <input type="text" value="Non-editable Question" readOnly style={{ width: '100%' }} />,
    [ItemTypes.TEXTAREA]: <textarea value="Non-editable Answer Text" readOnly style={{ width: '100%', height: '100%' }} />,
    [ItemTypes.CHECKBOX]: <label><input type="checkbox" disabled /> Checkbox</label>,
    [ItemTypes.RADIO]: <label><input type="radio" disabled /> Radio Button</label>,
    [ItemTypes.NEW_TEXT]: (
      <div>
        <TextComponent />
        <input
          type="text"
          value={question}
          onChange={handleQuestionChange}
          style={{ width: '100%', marginBottom: '20px', fontSize: '1.2em', marginTop: '10px' }}
        />
        {options.map((option, index) => (
          <input
            key={option.id}
            type="text"
            value={option.text}
            onChange={(e) => handleOptionChange(index, e.target.value)}
            style={{ width: '90%', marginBottom: '10px' }}
            placeholder={`Option ${index + 1}`}
          />
        ))}
        <button 
          onClick={addOption}
          style={{
            marginTop: '10px',
            padding: '8px 12px',
            backgroundColor: '#007bff', 
            color: 'white', 
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            fontSize: '14px',
          }}
        >
          Add Option
        </button>
      </div>
    ),
    [ItemTypes.NEW_CHECKBOX]: <CheckBoxComponent />,
  };

  return (
    <Rnd
      default={{
        x: left,
        y: top,
        width: width,
        height: height,
      }}
      bounds={canvasRef}
      onDragStop={onDragStop}
      onResizeStop={onResizeStop}
      enableResizing={{
        top: true,
        right: true,
        bottom: true,
        left: true,
        topRight: true,
        bottomRight: true,
        bottomLeft: true,
        topLeft: true,
      }} 
    >
      <div style={{ backgroundColor: 'white', padding: '5px', border: '1px solid black', borderRadius: '4px' }}>
        {inputTypes[type]}
        
        {/*<input
          type="text"
          value={question}
          onChange={handleQuestionChange}
          style={{ width: '100%', marginBottom: '10px', fontSize: '1.2em' }}
        />

        {options.map((option, index) => (
          <input
            key={option.id}
            type="text"
            value={option.text}
            onChange={(e) => handleOptionChange(index, e.target.value)}
            style={{ width: '100%', marginBottom: '5px' }}
            placeholder={`Option ${index + 1}`}
          />
        ))}

        <button onClick={addOption} style={{ marginTop: '10px' }}>
          Add Option
        </button>*/}
      </div>
    </Rnd>
  );
}



function App() {
  const [components, setComponents] = useState([]);
  
  const handleDrop = (x, y, type) => {
    const newComponent = {
      id: components.length + 1,
      type,
      x,
      y,
      width: type === ItemTypes.TEXTAREA ? 300 : 150,
      height: type === ItemTypes.TEXTAREA ? 100 : 40,
    };
    setComponents((prevComponents) => [...prevComponents, newComponent]);
  };

  const updateComponentPosition = (id, x, y) => {
    setComponents((prev) =>
      prev.map((comp) => (comp.id === id ? { ...comp, x, y } : comp))
    );
  };

  const updateComponentSize = (id, width, height) => {
    setComponents((prev) =>
      prev.map((comp) => (comp.id === id ? { ...comp, width: width, height: height } : comp))
    );
  };

  const saveLayout = () => {
    localStorage.setItem('canvasComponents', JSON.stringify(components));
    alert('Layout saved!');
    console.log('Layout saved:', components);
  };

  const loadLayout = () => {
    const savedComponents = localStorage.getItem('canvasComponents');
    if (savedComponents) {
      setComponents(JSON.parse(savedComponents));
    }
  };

  const handlePrint = () => {
    window.print();
  };

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="app">
        <div className="sidebar">
          <h3>Sidebar</h3>
          <SidebarItem type={ItemTypes.TEXT} label="Question" />
          <SidebarItem type={ItemTypes.TEXTAREA} label="Answer Text" />
          <SidebarItem type={ItemTypes.RADIO} label="Radio Button" />

          <SidebarItem type={ItemTypes.NEW_TEXT} label="New Text" />
          <SidebarItem type={ItemTypes.NEW_CHECKBOX} label="New Checkbox" />


          <button onClick={saveLayout}>Save Layout</button>
          <button onClick={loadLayout}>Load Layout</button>
          <button onClick={handlePrint}>Print Layout</button>
        </div>
        <CanvasArea onDrop={handleDrop}>
          {components.map((comp) => (
            <DraggableInput
              key={comp.id}
              type={comp.type}
              left={comp.x}
              top={comp.y}
              width={comp.width}
              height={comp.height}
              onDragStop={(e, d) => updateComponentPosition(comp.id, d.x, d.y)}
              onResizeStop={(e, direction, ref, delta, position) =>
                updateComponentSize(comp.id, ref.offsetWidth, ref.offsetHeight)
              }
            />
          ))}
        </CanvasArea>
      </div>
    </DndProvider>
  );
}

export default App;
